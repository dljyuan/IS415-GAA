---
title: "1st Order Spatial Point Patterns Analysis Methods"
execute: 
  eval: true
  echo: true
  warning: false
author: "Jin Yuan"
date: 01/18/2024
date-format: "DD/MM/YYYY"
editor: visual
---

# Getting Started

This hands-on exercise delves deeper into the intricacies of 1st Order Spatial Point Patterns Analysis Methods

## Installing and Loading Packages

```{r}
#| code-fold: true
#| code-summary: "Show Code"
pacman::p_load(maptools, sf, raster, spatstat, tmap)
```

## Importing Data

**A point feature data providing both location and attribute information of childcare centres**

```{r}
childcare_sf <- st_read("../data/geospatial/CHILDCARE.geojson") %>%
  st_transform(crs = 3414)
```

**A multipolygon feature data providing information of URA 2019 Master Plan Planning Subzone boundary data.**

```{r}
sg_sf <- st_read(dsn = "../data/geospatial/", 
                layer = "CostalOutline")
```

**A polygon feature data providing information of URA 2014 Master Plan Planning Subzone boundary data.**

```{r}
mpsz_sf <- st_read(dsn = "../data/geospatial/", 
                layer = "MP14_SUBZONE_WEB_PL")
```

**Converting CRS from WGS84 to SVY21**

```{r}
mpsz_sf <- st_transform(mpsz_sf, 3414)
st_geometry(mpsz_sf)
sg_sf <- st_transform(sg_sf, 3414)
st_geometry(sg_sf)
st_geometry(childcare_sf)
```

## Mapping the Geospatial Data Sets of Childcare Centres

**Static Mapping**

```{r}
tmap_mode("plot")
tm_shape(mpsz_sf) +
  tm_polygons() +
  tm_shape(childcare_sf) +
  tm_dots()
```

**Interactive Mode**

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```

## Geospatial Data wrangling

**Converting Geospatial data to Simple feature data frame**

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

**Convert to Generic SP Object** 

::: callout-note 
As spatstat requires the analytical data in ppp object form. There is no direct way to convert a Spatial classes into ppp object. We need to convert the Spatial classes into Spatial object first. 
:::

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

**Now, we will use as.ppp() function of spatstat to convert the spatial data into spatstat’s ppp object format.**
```{r}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

```{r}
plot(childcare_ppp)
summary(childcare_ppp)
```
::: callout-note
In spatial point patterns analysis an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are simple, that is, that the points cannot be coincident.
:::
**Check for Duplicate**
```{r}
any(duplicated(childcare_ppp))
```
**To show all of the co-indicence points**
```{r}
multiplicity(childcare_ppp)
```
**To count the number of co-indicence points**
```{r}
sum(multiplicity(childcare_ppp) > 1)
```
**To view the location of duplicate points**
```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
tmap_mode('plot')
```
::: callout-note
**3 Ways To Overcome**: 
1) Delete duplicates - Mean that some useful point events will be lost
2) Use jittering - which will add a small perturbation to the duplicate points so that they do not occupy the exact same space
3) Take them into account as marks - Make each point “unique” and then attach the duplicates of the points to the patterns as marks, as attributes of the points
:::

**Jittering Approach**
```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```
**Check again for duplicates**
```{r}
any(duplicated(childcare_ppp_jit))
```

:::callout-note
When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region.
:::

**Covert sg SpatialPolygon object into owin object of spatstat**
```{r}
sg_owin <- as(sg_sp, "owin")
plot(sg_owin)
summary(sg_owin)
```

## Combining point events object and owin object
```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
plot(childcareSG_ppp)
summary(childcareSG_ppp)
```
## First-order Spatial Point Patterns Analysis
### Kernel Density Estimation
**Computing kernel density estimation using automatic bandwidth selection method**
::: callout-note
Configuration of Density()
- bw.diggle() automatic bandwidth selection method. Other recommended methods are bw.CvL(), bw.scott() or bw.ppl().
- The smoothing kernel used is gaussian, which is the default. Other smoothing methods are: “epanechnikov”, “quartic” or “disc”.
- The intensity estimate is corrected for edge effect bias by using method described by Jones (1993) and Diggle (2010, equation 18.9). The default is FALSE.
:::
```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
plot(kde_childcareSG_bw)
```
**Retrieve the bandwidth used to compute the kde layer **
```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

### Rescalling KDE values
::: callout-note
The density values of the output range from 0 to 0.000035 which is way too small to comprehend. This is because the default unit of measurement of svy21 is in meter. As a result, the density values computed is in “number of points per square meter”.
:::

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

**Re-run density()**
```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```
### Working with different automatic badwidth methods
```{r}
bw.CvL(childcareSG_ppp.km)
bw.scott(childcareSG_ppp.km)
bw.ppl(childcareSG_ppp.km)
bw.diggle(childcareSG_ppp.km)
```

::: callout-note
Baddeley et. (2016) suggested the use of the bw.ppl() algorithm because in ther experience it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters. But they also insist that if the purpose of once study is to detect a single tight cluster in the midst of random noise then the bw.diggle() method seems to work best.
:::

**Comparing bw.diggle & bw.ppl**
```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

### Working with different kernel methods
```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

## Fixed and Adaptive KDE
### Computing KDE by using fixed bandwidth
::: callout-note
Next, you will compute a KDE layer by defining a bandwidth of 600 meter. Notice that in the code chunk below, the sigma value used is 0.6. This is because the unit of measurement of childcareSG_ppp.km object is in kilometer, hence the 600m is 0.6km.
:::

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

### Computing KDE by using fixed bandwidth
::: callout-note
Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.
:::

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

### Comparing between fixed and adaptive kde plot
```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

##  Converting KDE into grid object
**For mapping purpose**
```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)
```

### Converting gridded output into raster
```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
kde_childcareSG_bw_raster
```
::: callout-note
Notice that the crs property is NA.
:::

**Assigning projection systems**
```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```
## Visualising the output in tmap
```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

## Comparing Spatial Point Patterns using KDE
### Extracting study area

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

**Plot the study area**
```{r}
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

### Converting the spatial point data frame into generic sp format
```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

### Creating owin object
```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

### Combining childcare points and the study area
```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```
**Resale to km**

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

```{r}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

### Computing KDE
```{r}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Jurong West")
```


### Computing fixed bandwidth KDE
```{r}
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Jurong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

## Nearest Neighbour Analysis
::: callout-note
In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using clarkevans.test() of statspat.
:::

### Testing spatial point patterns using Clark and Evans Test
```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

### Clark and Evans Test: Choa Chu Kang planning area
```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

### Clark and Evans Test: Jurong West planning area
```{r}
clarkevans.test(childcare_jw_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```