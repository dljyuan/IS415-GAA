---
title: "Take-home Assignment 01: Discovering geographical distribution of Grab hailing services in Singapore"
author: "Jin Yuan"
date: 01/22/2024
date-modified: "last-modified"
date-format: "DD/MM/YYYY"
editor: visual
format: html
categories:
  - Take-home Assignment
title-block-categories: false
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

# Background

In this exploration, we investigate the geographical and spatio-temporal distribution of Grab hailing services in Singapore, leveraging the rich dataset provided by GRAB known as Grab Posisi. As a significant shared taxi operator in Southeast Asia, GRAB's dataset offers a unique perspective on human mobility. This study focuses on applying Spatial Point Pattern Analyses (KDE/NKDE) to discern patterns within the dataset.

# Install Packages & Importing Data

## Install Necessary Packages

For this exercise, we will be using the following packages:

**sf** for importing, managing, and processing geospatial data through simple features.

**tidyverse** for comprehensive data science tasks, including importing, wrangling, and visualizing spatial data.

**spatstat** for point pattern analysis, offering a wide range of functions for exploring spatial patterns.

**spNetwork** for analyzing spatial networks and their properties.

**classInt** for determining class intervals for mapping and visualization purposes.

**viridis** for providing color maps suitable for creating visually appealing visualizations.

**maptools** for manipulating geographic data, offering a set of tools for various spatial operations.

**raster** for reading, writing, manipulating, and analyzing gridded spatial data in a raster format.

**arrow** for reading parquet files and to load the dataset

```{r}
pacman::p_load(tmap, sf, tidyverse, spatstat, spNetwork, classInt, viridis,
               maptools, raster, arrow)
```

## Importing Data

**GrabPosisi Data (Pick Up Location)**

```{r eval=FALSE}
#GrabPosisi Data
df <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00000.parquet")
df2 <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00001.parquet")
df3 <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00002.parquet")
df4 <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00003.parquet")
df5 <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00004.parquet")
df6 <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00005.parquet")
df7 <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00006.parquet")
df8 <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00007.parquet")
df9 <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00008.parquet")
df10 <- arrow::read_parquet("/dljyuan/IS415-GAA/data/GrabPosisi/part-00009.parquet")
```

**Convert time variable to datetime format**

```{r eval=FALSE}
df$pingtimestamp <- as_datetime(df$pingtimestamp)
df2$pingtimestamp <- as_datetime(df2$pingtimestamp)
df3$pingtimestamp <- as_datetime(df3$pingtimestamp)
df4$pingtimestamp <- as_datetime(df4$pingtimestamp)
df5$pingtimestamp <- as_datetime(df5$pingtimestamp)
df6$pingtimestamp <- as_datetime(df6$pingtimestamp)
df7$pingtimestamp <- as_datetime(df7$pingtimestamp)
df8$pingtimestamp <- as_datetime(df8$pingtimestamp)
df9$pingtimestamp <- as_datetime(df9$pingtimestamp)
df10$pingtimestamp <- as_datetime(df10$pingtimestamp)
```

**Extracting origin location (Pickup Points)**

```{r eval=FALSE}
# Code repeated for all the other df
origin_df <- df %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr=TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```

**Combine all df together**

```{r eval=FALSE}
combined_origin_df <- rbind(origin_df, origin_df2,origin_df3,origin_df4,origin_df5,origin_df6,origin_df7,origin_df8,origin_df9,origin_df10)
```

```{r eval=FALSE, echo=FALSE}
write_rds(combined_origin_df, "/dljyuan/IS415-GAA/data/rds/combined_origin_df.rds")
```

```{r echo=FALSE}
origin_df <- read_rds("/dljyuan/IS415-GAA/data/rds/origin_df.rds")
```

::: callout-note
For in class assignment, we are not going to combine the 10 different parquet files but only used one of them for entire analysis
:::

**Boundary Data (Coastal Outline)**

```{r}
mpsz_sf <- st_read(dsn = "../data/geospatial/",
                   layer="MPSZ-2019")
sg_sf <- mpsz_sf %>%  st_combine()
sg_sf <- st_make_valid(sg_sf)
length(which(st_is_valid(sg_sf) == FALSE))
```

**Road Layer Data (Singapore)** The following include data from Singapore, Malaysia & Brunei

```{r eval=FALSE}
road <- st_read(dsn="../data/geospatial",
                   layer="gis_osm_roads_free_1")
```

Convert CRS of Road Data to be the same as the Coastal Outline (SVY21)

```{r eval=FALSE}
road <- st_transform(road, crs = 3414)
sg_sf <- st_transform(sg_sf, crs = 3414)
st_geometry(sg_sf)
st_geometry(road)
```

```{r}
sg_sf <- st_transform(sg_sf, crs = 3414)
st_geometry(sg_sf)
mpsz_sf <- st_transform(mpsz_sf, crs = 3414)
st_geometry(mpsz_sf)
```

Filter out unnecessary variables

```{r}
#road <- road[, c("name", "geometry")]
origin_df <- origin_df[, c("trj_id", "rawlat", "rawlng", "accuracy", "weekday", "start_hr", "day")]
```

Extracting road data from Singapore only

```{r eval=FALSE}
singapore_roads <- st_intersection(road, sg_sf)
```

```{r}
#| eval: false
#| echo: false
write_rds(singapore_roads, "/dljyuan/IS415-GAA/data/rds/singapore_roads.rds")
```

**Import SG Road Layers**

```{r echo=FALSE}
singapore_roads <- read_rds("/dljyuan/IS415-GAA/data/rds/singapore_roads.rds")
```

# Data Wrangling

**Convert Data CRS to 3414 SVY21**

```{r}
singapore_roads <- st_transform(singapore_roads, crs = 3414)
```

```{r eval=FALSE}
tmap_mode('plot')
tm_shape(singapore_roads) +
  tm_lines()
```

![](/image/THA-15.png)

**Convert Latitude & Longtitude to Cartisians**

```{r}
origin_df <- st_as_sf(origin_df, 
                       coords = c("rawlng", "rawlat"),
                       crs=4326) %>%
  st_transform(crs = 3414)
```

```{r eval=FALSE}
tm_shape(origin_df) +
  tm_dots() 
```

![](/image/THA-01.png)

**Convert to Spatial Class**

```{r}
origin <- as_Spatial(origin_df)
sg <- as_Spatial(sg_sf)
#singapore_roads <- as_Spatial(singapore_roads)
```

**Convert to Spatial Object**

```{r}
origin_sp <- as(origin, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

**Convert to ppp Object**

```{r}
origin_ppp <- as(origin_sp, "ppp")
```

**Check for duplicate or overlap points**

```{r eval=FALSE}
tmap_mode('plot')
tm_shape(sg_sf) +
  tm_polygons() +
  tm_shape(origin) +
  tm_dots(alpha=0.4, 
          size=0.02)
```

![](/image/THA-02.png)

```{r}
any(duplicated(origin_ppp))
sum(multiplicity(origin_ppp) > 1)
```

**Removing Duplicate Points**

```{r}
origin_ppp <- rjitter(origin_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
any(duplicated(origin_ppp))
```

**Convert to owin Object**

```{r}
sg_owin <- as(sg_sp, "owin")
```

**Combine Grabposisi Data with Coastal Outline**

```{r eval=FALSE}
origin_ppp = origin_ppp[sg_owin]
plot(origin_ppp)
```

![](/image/THA-16.png)

# Exploratory Data Analysis

## Kernel Density Estimation (KDE)

```{r}
# Convert data to km as our unit of measurement
origin_ppp.km <- rescale(origin_ppp, 1000, "km")
```

**Selecting Kernel Method**

Baddeley et. (2016) suggested the use of the bw.ppl() algorithm because in ther experience it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters. But they also insist that if the purpose of once study is to detect a single tight cluster in the midst of random noise then the bw.diggle() method seems to work best.

```{r eval=FALSE}
par(mfrow=c(1,2))
plot(density(origin_ppp.km, 
  sigma=bw.diggle, 
  edge=TRUE,
  kernel="gaussian"),
  main = "bw.diggle")

plot(density(origin_ppp.km, 
  sigma=bw.ppl, 
  edge=TRUE,
  kernel="gaussian"),
  main = "bw.ppl")
```

![](/image/THA-03.png)

The map **bw.ppl** might show sharper contrasts and potentially reveal more nuanced clusters or patterns in the point distribution compared to the **bw.diggle** map.

```{r eval=FALSE}
par(mfrow=c(2,2))
plot(density(origin_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(origin_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(origin_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(origin_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

![](images/THA-04.jpg) While the four KDE maps exhibit overall similarities, closer inspection reveals subtle differences in density patterns. For this analysis we will utilize the **Gaussian kernel** for this analysis.

```{r eval=FALSE}
kde_origin.ppl <- density(origin_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
```

**Comparing Fixed & Adaptive KDE**

```{r eval=FALSE}
kde_origin_adaptive <- adaptive.density(origin_ppp.km, method="kernel")
par(mfrow=c(1,2))
plot(kde_origin.ppl, main = "Fixed bandwidth")
plot(kde_origin_adaptive, main = "Adaptive bandwidth")
```

![](images/THA-05.png) Based on visual analysis of the KDE maps, fixed bandwidth will produce a more accurate and interpretable representation of the underlying data distribution as compared to adaptive bandwidth.

**Converting KDE into grid object**

```{r eval=FALSE}
gridded_kde_origin_ppl <- as.SpatialGridDataFrame.im(kde_origin.ppl)
kde_origin_ppl_raster <- raster(gridded_kde_origin_ppl)
projection(kde_origin_ppl_raster) <- CRS("+init=EPSG:3414")
```

**Visualising Output Map**

```{r eval=FALSE}
tm_shape(kde_origin_ppl_raster) + 
  tm_raster("v", palette = "YlGnBu", title="") +
  tm_layout(
    legend.position = c("right", "bottom"), 
    main.title = "Pick Up Points Density",
    frame = FALSE)
```

![](images/THA-06.png)

The map reveals several distinct clusters of high-density points, particularly concentrated in the southeastern and southern quadrants. These clusters could be further analyzed by dividing them into five distinct regions.

## Network Kernel Density Estimation (NKDE)

The five high-density regions identified in the standard KDE analysis will be the focus of network kernel density estimation. This will leverage the network's inherent connections and potentially uncover deeper insights and relationships within these areas.

![](images/THA-14.png) **Retrieving the five study areas** Changi

```{r}
ch <- mpsz_sf %>%
  filter(PLN_AREA_N == "CHANGI")
ch <- ch%>%
  st_union()
ch <- st_make_valid(ch)
length(which(st_is_valid(ch) == FALSE))
```

Town

```{r}
town <- mpsz_sf %>%
  filter(PLN_AREA_N %in% c("OUTRAM","DOWNTOWN CORE","SINGAPORE RIVER","MUSEUM", "ROCHOR","RIVER VALLEY", "STRAITS VIEW", "MARINA SOUTH"))
town <- town%>%
  st_union()
town <- st_make_valid(town)
length(which(st_is_valid(town) == FALSE))
```

Woodlands

```{r}
wood <- mpsz_sf %>%
  filter(PLN_AREA_N == "WOODLANDS")
wood <- wood%>%
  st_union()
wood <- st_make_valid(wood)
length(which(st_is_valid(wood) == FALSE))
```

Choa Chu Kang

```{r}
cck_bp <- mpsz_sf %>%
  filter(PLN_AREA_N %in% c("CHOA CHU KANG","BUKIT PANJANG"))

cck_bp <- cck_bp%>%
  st_union()

cck_bp <- st_make_valid(cck_bp)
length(which(st_is_valid(cck_bp) == FALSE))
```

Jurong

```{r}
jg <- mpsz_sf %>%
  filter(PLN_AREA_N %in% c("JURONG WEST","JURONG EAST","CLEMENTI"))
jg <- jg%>%
  st_union()
jg <- st_make_valid(jg)
length(which(st_is_valid(jg) == FALSE))
```

**Converting to SVY21 3414**

```{r}
ch <- st_transform(ch, crs = 3414)
town <- st_transform(town, crs = 3414)
wood <- st_transform(wood, crs = 3414)
cck_bp <- st_transform(cck_bp, crs = 3414)
jg <- st_transform(jg, crs = 3414)
```

**Extracting the road layers for each individual area**

```{r warning=FALSE}
ch_roads <- st_intersection(singapore_roads, ch)
town_roads <- st_intersection(singapore_roads, town)
wood_roads <- st_intersection(singapore_roads, wood)
cck_bp_roads <- st_intersection(singapore_roads, cck_bp)
jg_roads <- st_intersection(singapore_roads, jg)
```

**Visualising the extract spatial data**

```{r eval=FALSE}
par(mfrow=c(2,3))
plot(ch, main = "Changi Area")
plot(town, main = "Town Area")
plot(wood, main = "Woodlands Area")
plot(cck_bp, main = "Choa Chu Kang Area")
plot(jg, main = "Jurong Area")
```

![](images/THA-07.png)

::: {.panel-tabset .nav-pills}
## Changi Area

```{r eval=FALSE}
plot(ch_roads[, c("osm_id", "name")])
```

![](images/Changi_Rd.png)

## Town Area

```{r eval=FALSE}
plot(town_roads[, c("osm_id", "name")])
```

![](images/Town_Rd.png)

## Woodlands Area

```{r eval=FALSE}
plot(wood_roads[, c("osm_id", "name")])
```

![](images/Woodlands_Rd.png)

## Choa Chu Kang Area

```{r eval=FALSE}
plot(cck_bp_roads[, c("osm_id", "name")])
```

![](images/CCK_Rd.png)

## Jurong Area

```{r eval=FALSE}
plot(jg_roads[, c("osm_id", "name")])
```

![](images/Jurong_Rd.png)
:::

```{r eval=FALSE}
tmap_arrange(tm_shape(ch_roads) +
               tm_lines(col = "red") +
               tm_layout(title = "Changi", title.size = 0.8),
             tm_shape(town_roads) +
               tm_lines(col = "blue") +
               tm_layout(title = "Town", title.size = 0.8), 
             tm_shape(wood_roads) +
               tm_lines(col = "green") +
               tm_layout(title = "Woodlands", title.size = 0.8),
             tm_shape(cck_bp_roads) +
               tm_lines(col = "orange") +
               tm_layout(title = "Choa Chu Kang", title.size = 0.8),
             tm_shape(jg_roads) +
               tm_lines(col = "purple") +
               tm_layout(title = "Jurong", title.size = 0.8), 
             asp=2, ncol=3)
```

![](images/THA-08.png)

**Converting the geometry format to linestring.**

```{r warning=FALSE}
ch_roads <- st_cast(ch_roads, "LINESTRING")
town_roads <- st_cast(town_roads, "LINESTRING")
wood_roads <- st_cast(wood_roads, "LINESTRING")
cck_bp_roads <- st_cast(cck_bp_roads, "LINESTRING")
jg_roads <- st_cast(jg_roads, "LINESTRING")
```

**Preparing lixels object & generating line centre points**

```{r eval=FALSE}
lixels_ch <- lixelize_lines(ch_roads, 
                         700, 
                         mindist = 350)
lixels_town <- lixelize_lines(town_roads, 
                         700, 
                         mindist = 350)
lixels_wood <- lixelize_lines(wood_roads, 
                         700, 
                         mindist = 350)
lixels_cck_bp <- lixelize_lines(cck_bp_roads, 
                         700, 
                         mindist = 350)
lixels_jg <- lixelize_lines(jg_roads, 
                         700, 
                         mindist = 350)
```

**Retrieving the pickup points for each study area**

```{r eval=FALSE}
samples_ch <- lines_center(lixels_ch)
samples_town <- lines_center(lixels_town)
samples_wood <- lines_center(lixels_wood)
samples_cck_bp <- lines_center(lixels_cck_bp)
samples_jg <- lines_center(lixels_jg)
```

```{r warning=FALSE}
origin_ch = st_intersection(origin_df, ch)
origin_town = st_intersection(origin_df, town)
origin_wood = st_intersection(origin_df, wood)
origin_cck_bp = st_intersection(origin_df, cck_bp)
origin_jg = st_intersection(origin_df, jg)
```

**Performing NetKDE**

```{r eval=FALSE}
# This code is repeated for the remaining 5 area except the variables for [lines, events, w & samples]
densities <- nkde(ch_roads, 
                  events = origin_ch,
                  w = rep(1,nrow(origin_ch)),
                  samples = samples_ch,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)

samples_ch$density <- densities*1000
lixels_ch$density <- densities*1000
```

```{r eval=FALSE, echo=FALSE}
write_rds(lixels_ch, "/dljyuan/IS415-GAA/data/rds/lixels_ch.rds")
```

```{r echo=FALSE}
lixels_ch = read_rds("/dljyuan/IS415-GAA/data/rds/lixels_ch.rds")
lixels_town = read_rds("/dljyuan/IS415-GAA/data/rds/lixels_town.rds")
lixels_wood = read_rds("/dljyuan/IS415-GAA/data/rds/lixels_wood.rds")
lixels_cck_bp = read_rds("/dljyuan/IS415-GAA/data/rds/lixels_cck_bp.rds")
lixels_jg = read_rds("/dljyuan/IS415-GAA/data/rds/lixels_jg.rds")
```

::: {.panel-tabset .nav-pills}
## Changi

```{r eval=TRUE}
tmap_mode('plot')
tm_shape(lixels_ch)+
  tm_lines(col="density")+
tm_shape(origin_ch)+
  tm_dots()
```

## Town

```{r eval=TRUE}
tmap_mode('plot')
tm_shape(lixels_town)+
  tm_lines(col="density")+
tm_shape(origin_town)+
  tm_dots()
```

## Woodlands

```{r}
tmap_mode('plot')
tm_shape(lixels_wood)+
  tm_lines(col="density")+
tm_shape(origin_wood)+
  tm_dots()
```

## Choa Chu Kang

```{r eval=TRUE}
tmap_mode('plot')
tm_shape(lixels_cck_bp)+
  tm_lines(col="density")+
tm_shape(origin_cck_bp)+
  tm_dots()
```

## Jurong

```{r eval=TRUE}
tmap_mode('plot')
tm_shape(lixels_jg)+
  tm_lines(col="density")+
tm_shape(origin_jg)+
  tm_dots()
```
:::

::: callout-note
Enhance clarity by hovering over the map icon and deselecting 'origin\_\*' to reveal a more distinct concentration of pick-up points.
:::

# Conclusion

The Grab Posisi dataset has provided numerous intriguing findings through the application of Spatial Point Analysis. In the course of the analysis, the findings can be used to assist drivers in identifying optimal areas for passenger pick-ups, ensuring a more efficient use of their working time. Furthermore, the analysis has the potential to reveal insights into the factors contributing to the various traffic hotspots in Singapore.
